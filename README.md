# Stack Analyzer

A Python tool to analyze stack usage in C/C++ programs by combining compiler-generated stack usage information (`.su` files) with function call graphs (generated by `cflow`). This helps identify potential stack overflow issues in embedded systems or resource-constrained environments.

## Features

- Recursively scans directories for `.su` files generated by GCC
- Parses call graphs from `cflow` output
- Calculates both direct and total stack usage for each function
- Generates a comprehensive JSON report of stack usage analysis
- Identifies the full call chain contributing to stack usage

## Requirements
- Python 3.6+
- GCC with stack usage reporting capability
- GNU cflow
```bash
sudo apt install python3 gcc cflow
```

## Usage

To see all available options:

```bash
python stack_analyzer.py --help
```
## Generating .su Files

To generate `.su` files, compile your C/C++ code with GCC using the `-fstack-usage` flag:

### For GCC

```bash
gcc -fstack-usage -c file.c
```

This will produce a `.su` file alongside each object file, containing stack usage information.

### In a Makefile

Add the flag to your CFLAGS:

```makefile
CFLAGS += -fstack-usage
```

### CMake Example

```cmake
add_compile_options(-fstack-usage)
```

## Generating cflow Output

The tool expects cflow output in the GNU format with levels printed. Generate it using:

```bash
cflow --all --format=gnu --print-level <source-files> > callgraph.txt
```

## Output Format

The tool generates a JSON file with the following structure:

```json
[
  {
    "file": "source_file.c",
    "function": "function_name",
    "direct_usage": 48,
    "total_usage": 184,
    "type": "dynamic",
    "called_functions": [
      {
        "file": "other_file.c",
        "function": "called_function",
        "total_usage": 136
      }
    ]
  }
]
```

## License

This project is licensed under the terms of the license included in the repository.
